.TH "ltc.h" 3 "Fri Nov 2 2012" "Version 1.0.0" "libltc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ltc.h \- 
.PP
libltc - en+decode linear timecode  

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBLTCFrame\fP"
.br
.ti -1c
.RI "struct \fBLTCFrameExt\fP"
.br
.ti -1c
.RI "struct \fBSMPTETimecode\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLTC_FRAME_BIT_COUNT\fP   80"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned char \fBltcsnd_sample_t\fP"
.br
.ti -1c
.RI "typedef long long int \fBltc_off_t\fP"
.br
.ti -1c
.RI "typedef struct \fBLTCFrame\fP \fBLTCFrame\fP"
.br
.ti -1c
.RI "typedef struct \fBLTCFrameExt\fP \fBLTCFrameExt\fP"
.br
.ti -1c
.RI "typedef struct \fBSMPTETimecode\fP \fBSMPTETimecode\fP"
.br
.ti -1c
.RI "typedef struct \fBLTCDecoder\fP \fBLTCDecoder\fP"
.br
.ti -1c
.RI "typedef struct \fBLTCEncoder\fP \fBLTCEncoder\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBltc_frame_to_time\fP (\fBSMPTETimecode\fP *stime, \fBLTCFrame\fP *frame, int set_date)"
.br
.ti -1c
.RI "void \fBltc_time_to_frame\fP (\fBLTCFrame\fP *frame, \fBSMPTETimecode\fP *stime, int set_date)"
.br
.ti -1c
.RI "void \fBltc_frame_reset\fP (\fBLTCFrame\fP *frame)"
.br
.ti -1c
.RI "int \fBltc_frame_increment\fP (\fBLTCFrame\fP *frame, int fps, int use_date)"
.br
.ti -1c
.RI "int \fBltc_frame_decrement\fP (\fBLTCFrame\fP *frame, int fps, int use_date)"
.br
.ti -1c
.RI "\fBLTCDecoder\fP * \fBltc_decoder_create\fP (int apv, int queue_size)"
.br
.ti -1c
.RI "int \fBltc_decoder_free\fP (\fBLTCDecoder\fP *d)"
.br
.ti -1c
.RI "void \fBltc_decoder_write\fP (\fBLTCDecoder\fP *d, \fBltcsnd_sample_t\fP *buf, size_t size, \fBltc_off_t\fP posinfo)"
.br
.ti -1c
.RI "void \fBltc_decoder_write_float\fP (\fBLTCDecoder\fP *d, float *buf, size_t size, \fBltc_off_t\fP posinfo)"
.br
.ti -1c
.RI "void \fBltc_decoder_write_s16\fP (\fBLTCDecoder\fP *d, short *buf, size_t size, \fBltc_off_t\fP posinfo)"
.br
.ti -1c
.RI "void \fBltc_decoder_write_u16\fP (\fBLTCDecoder\fP *d, short *buf, size_t size, \fBltc_off_t\fP posinfo)"
.br
.ti -1c
.RI "int \fBltc_decoder_read\fP (\fBLTCDecoder\fP *d, \fBLTCFrameExt\fP *frame)"
.br
.ti -1c
.RI "void \fBltc_decoder_queue_flush\fP (\fBLTCDecoder\fP *d)"
.br
.ti -1c
.RI "int \fBltc_decoder_queue_length\fP (\fBLTCDecoder\fP *d)"
.br
.ti -1c
.RI "\fBLTCEncoder\fP * \fBltc_encoder_create\fP (double sample_rate, double fps, int use_date)"
.br
.ti -1c
.RI "void \fBltc_encoder_free\fP (\fBLTCEncoder\fP *e)"
.br
.ti -1c
.RI "void \fBltc_encoder_set_timecode\fP (\fBLTCEncoder\fP *e, \fBSMPTETimecode\fP *t)"
.br
.ti -1c
.RI "void \fBltc_encoder_get_timecode\fP (\fBLTCEncoder\fP *e, \fBSMPTETimecode\fP *t)"
.br
.ti -1c
.RI "int \fBltc_encoder_inc_timecode\fP (\fBLTCEncoder\fP *e)"
.br
.ti -1c
.RI "int \fBltc_encoder_dec_timecode\fP (\fBLTCEncoder\fP *e)"
.br
.ti -1c
.RI "void \fBltc_encoder_set_frame\fP (\fBLTCEncoder\fP *e, \fBLTCFrame\fP *f)"
.br
.ti -1c
.RI "void \fBltc_encoder_get_frame\fP (\fBLTCEncoder\fP *e, \fBLTCFrame\fP *f)"
.br
.ti -1c
.RI "int \fBltc_encoder_get_buffer\fP (\fBLTCEncoder\fP *e, \fBltcsnd_sample_t\fP *buf)"
.br
.ti -1c
.RI "\fBltcsnd_sample_t\fP * \fBltc_encoder_get_bufptr\fP (\fBLTCEncoder\fP *e, int *size, int flush)"
.br
.ti -1c
.RI "void \fBltc_encoder_buffer_flush\fP (\fBLTCEncoder\fP *e)"
.br
.ti -1c
.RI "size_t \fBltc_encoder_get_buffersize\fP (\fBLTCEncoder\fP *e)"
.br
.ti -1c
.RI "int \fBltc_encoder_reinit\fP (\fBLTCEncoder\fP *e, double sample_rate, double fps, int use_date)"
.br
.ti -1c
.RI "int \fBltc_encoder_set_bufsize\fP (\fBLTCEncoder\fP *e, double sample_rate, double fps)"
.br
.ti -1c
.RI "int \fBltc_encoder_set_volume\fP (\fBLTCEncoder\fP *e, double dBFS)"
.br
.ti -1c
.RI "void \fBltc_encoder_set_filter\fP (\fBLTCEncoder\fP *e, double rise_time)"
.br
.ti -1c
.RI "int \fBltc_encoder_encode_byte\fP (\fBLTCEncoder\fP *e, int byte, double speed)"
.br
.ti -1c
.RI "void \fBltc_encoder_encode_frame\fP (\fBLTCEncoder\fP *e)"
.br
.ti -1c
.RI "void \fBltc_frame_set_parity\fP (\fBLTCFrame\fP *frame)"
.br
.in -1c
.SH "Detailed Description"
.PP 
libltc - en+decode linear timecode 

Linear (or Longitudinal) Timecode (LTC) is an encoding of timecode data as a Manchester-Biphase encoded audio signal\&. The audio signal is commonly recorded on a VTR track or other storage media\&.
.PP
libltc facilitates decoding and encoding of LTC from/to timecode, including SMPTE date support\&.
.PP
\fBAuthor:\fP
.RS 4
Robin Gareus robin@gareus.org 
.RE
.PP
\fBCopyright:\fP
.RS 4
.RE
.PP
Copyright (C) 2006-2012 Robin Gareus robin@gareus.org
.PP
Copyright (C) 2008-2009 Jan WeiÃŸ jan@geheimwerk.de
.PP
Inspired by SMPTE Decoder - Maarten de Boer mdeboer@iua.upf.es
.PP
This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version\&.
.PP
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE\&. See the GNU Lesser General Public License for more details\&.
.PP
You should have received a copy of the GNU Lesser General Public License along with this library\&. If not, see http://www.gnu.org/licenses/\&. 
.SH "Data Structure Documentation"
.PP 
.SH "struct LTCFrame"
.PP 
Raw 80 bit LTC frame
.PP
The datastream for each video frame of Longitudinal TimeCode consists of eighty bit-periods\&.
.PP
At a frame-rate of 30 fps, the bit-rate corresponds to 30 [fps] * 80 [bits/f] = 2400 bits per second\&. The frequency for a stream of zeros would be 1\&.2 kHz and for a stream of ones it would be 2\&.4 kHz\&.  With all commonly used video-frame-rates and audio-sample-rates, LTC timecode can be recorded easily into a audio-track\&.
.PP
In each frame, 26 of the eighty bits carry the SMPTE time in binary coded decimal (BCD)\&.
.PP
These Bits are FRAME-UNITS, FRAME-TENS, SECS-UNITS, SECS-TENS, MINS-UNITS, MINS-TENS, HOURS-UNITS and HOURS-TENS\&. The BCD digits are loaded 'least significant bit first' (libltc takes care of the architecture specific alignment)\&.
.PP
32 bits are assigned as eight groups of four USER-BITS (also sometimes called the 'Binary Groups')\&. This capacity is generally used to carry extra info such as reel number and/or date\&. The User Bits may be allocated howsoever one wishes as long as both Binary Group Flag Bits are cleared\&.
.PP
The last 16 Bits make up the SYNC WORD\&. These bits indicate the frame boundary, the tape direction, and the bit-rate of the sync tone\&. The values of these Bits are fixed as 0011 1111 1111 1101
.PP
The Bi-Phase Mark Phase Correction Bit (Bit 27) may be set or cleared so that that every 80-bit word contains an even number of zeroes\&. This means that the phase of the pulse train in every Sync Word will be the same\&.
.PP
Bit 10 indicates drop-frame timecode\&. The Colour Frame Flag col\&.frm is Bit 11; if the timecode intentionally synchronized to a colour TV field sequence, this bit is set\&.
.PP
Bit 58 is not required for the BCD count for HOURS-TENS (which has a maximum value of two) and has not been given any other special purpose so remains unassigned\&. This Bit has been RESERVED for future assignment\&.
.PP
Bits 43 and 59 are assigned as the Binary Group Flag Bits\&. These Bits are used to indicate when a standard character set is used to format the User Bits data\&. The Binary Group Flag Bits should be used only as shown in the truth table below\&. The Unassigned entries in the table should not be used, as they may be allocated specific meanings in the future\&.
.PP
.PP
.nf

                                 Bit 43  Bit 59
 No User Bits format specified     0       0
 Eight-bit character set           1       0
 Unassigned (Reserved)             0       1
 Unassigned (Reserved)             1       1
.fi
.PP
.PP
further information: http://www.philrees.co.uk/articles/timecode.htm 
.PP
\fBData Fields:\fP
.RS 4
unsigned int \fIbinary_group_flag_bit1:1\fP indicate user-data char encoding, see table above 
.br
.PP
unsigned int \fIbinary_group_flag_bit2:1\fP indicate user-data char encoding, see table above 
.br
.PP
unsigned int \fIbiphase_mark_phase_correction:1\fP unused - see note on Bit 27 in description and \fBltc_frame_set_parity\fP \&. 
.br
.PP
unsigned int \fIcol_frame:1\fP colour-frame: timecode intentionally synchronized to a colour TV field sequence 
.br
.PP
unsigned int \fIdfbit:1\fP indicated drop-frame timecode 
.br
.PP
unsigned int \fIframe_tens:2\fP SMPTE framenumber BCD tens 0\&.\&.3\&. 
.br
.PP
unsigned int \fIframe_units:4\fP SMPTE framenumber BCD unit 0\&.\&.9\&. 
.br
.PP
unsigned int \fIhours_tens:2\fP SMPTE hours BCD tens 0\&.\&.2\&. 
.br
.PP
unsigned int \fIhours_units:4\fP SMPTE hours BCD unit 0\&.\&.9\&. 
.br
.PP
unsigned int \fImins_tens:3\fP SMPTE minutes BCD tens 0\&.\&.6\&. 
.br
.PP
unsigned int \fImins_units:4\fP SMPTE minutes BCD unit 0\&.\&.9\&. 
.br
.PP
unsigned int \fIreserved:1\fP reserved -- don't use 
.br
.PP
unsigned int \fIsecs_tens:3\fP SMPTE seconds BCD tens 0\&.\&.6\&. 
.br
.PP
unsigned int \fIsecs_units:4\fP SMPTE seconds BCD unit 0\&.\&.9\&. 
.br
.PP
unsigned int \fIsync_word:16\fP 
.br
.PP
unsigned int \fIuser1:4\fP 
.br
.PP
unsigned int \fIuser2:4\fP 
.br
.PP
unsigned int \fIuser3:4\fP 
.br
.PP
unsigned int \fIuser4:4\fP 
.br
.PP
unsigned int \fIuser5:4\fP 
.br
.PP
unsigned int \fIuser6:4\fP 
.br
.PP
unsigned int \fIuser7:4\fP 
.br
.PP
unsigned int \fIuser8:4\fP 
.br
.PP
.RE
.PP
.SH "struct LTCFrameExt"
.PP 
Extended LTC frame - includes audio-sample position offsets, volume, etc 
.PP
\fBExamples: \fP
.in +1c
\fBltcdecode\&.c\fP\&.
.PP
\fBData Fields:\fP
.RS 4
float \fIbiphase_tics\fP detailed timing info: phase of the LTC signal; the time between each bit in the LTC-frame in audio-frames\&. Summing all 80 values in the array will yield audio-frames/LTC-frame = (\fBoff_end\fP - \fBoff_start\fP + 1)\&. 
.br
.PP
\fBLTCFrame\fP \fIltc\fP the actual LTC frame\&. see \fBLTCFrame\fP 
.br
.PP
\fBltc_off_t\fP \fIoff_end\fP the sample in the stream corresponding to the end of the LTC frame\&. 
.br
.PP
\fBltc_off_t\fP \fIoff_start\fP the approximate sample in the stream corresponding to the start of the LTC frame\&. 
.br
.PP
int \fIreverse\fP if non-zero, a reverse played LTC frame was detected\&. Since the frame was reversed, it started at off_end and finishes as off_start (off_end > off_start)\&. (Note: in reverse playback the (reversed) sync-word of the next/previous frame is detected, this offset is corrected)\&. 
.br
.PP
\fBltcsnd_sample_t\fP \fIsample_max\fP the maximum input sample signal for this frame (0\&.\&.255) 
.br
.PP
\fBltcsnd_sample_t\fP \fIsample_min\fP the minimum input sample signal for this frame (0\&.\&.255) 
.br
.PP
double \fIvolume\fP the volume of the input signal in dbFS 
.br
.PP
.RE
.PP
.SH "struct SMPTETimecode"
.PP 
Human readable time representation, decimal values\&. 
.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP, \fBltcdecode\&.c\fP, and \fBltcencode\&.c\fP\&.
.PP
\fBData Fields:\fP
.RS 4
unsigned char \fIdays\fP day of month 1\&.\&.31 
.br
.PP
unsigned char \fIframe\fP sub-second frame 0\&.\&.{FPS-1} 
.br
.PP
unsigned char \fIhours\fP hour 0\&.\&.23 
.br
.PP
unsigned char \fImins\fP minute 0\&.\&.60 
.br
.PP
unsigned char \fImonths\fP valid months are 1\&.\&.12 
.br
.PP
unsigned char \fIsecs\fP second 0\&.\&.60 
.br
.PP
char \fItimezone\fP 
.br
.PP
unsigned char \fIyears\fP LTC-date uses 2-digit year 00\&.99\&. 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define LTC_FRAME_BIT_COUNT   80"

.SH "Typedef Documentation"
.PP 
.SS "typedef long long int \fBltc_off_t\fP"
sample-count offset - 64bit wide 
.SS "typedef struct \fBLTCDecoder\fP \fBLTCDecoder\fP"
opaque structure\&. see: \fBltc_decoder_create\fP, \fBltc_decoder_free\fP 
.SS "typedef struct \fBLTCEncoder\fP \fBLTCEncoder\fP"
opaque structure see: \fBltc_encoder_create\fP, \fBltc_encoder_free\fP 
.SS "typedef struct \fBLTCFrame\fP \fBLTCFrame\fP"
see \fBLTCFrame\fP 
.SS "typedef struct \fBLTCFrameExt\fP \fBLTCFrameExt\fP"
see \fBLTCFrameExt\fP 
.SS "typedef unsigned char \fBltcsnd_sample_t\fP"
default audio sample type: 8bit unsigned (mono) 
.SS "typedef struct \fBSMPTETimecode\fP \fBSMPTETimecode\fP"
see \fBSMPTETimecode\fP 
.SH "Function Documentation"
.PP 
.SS "\fBLTCDecoder\fP* ltc_decoder_create (int apv, int queue_size)"
Create a new LTC decoder\&.
.PP
\fBParameters:\fP
.RS 4
\fIapv\fP audio-frames per video frame\&. This is just used for initial settings, the speed is tracked dynamically\&. setting this in the right ballpark is needed to properly decode the first LTC frame in a sequence\&. 
.br
\fIqueue_size\fP length of the internal queue to store decoded frames to SMPTEDecoderWrite\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
decoder handle or NULL if out-of-memory 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcdecode\&.c\fP\&.
.SS "int ltc_decoder_free (\fBLTCDecoder\fP * d)"
release memory of decoder-structure\&. 
.PP
\fBParameters:\fP
.RS 4
\fId\fP decoder handle 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcdecode\&.c\fP\&.
.SS "void ltc_decoder_queue_flush (\fBLTCDecoder\fP * d)"
removed all frames from queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fId\fP decoder handle 
.RE
.PP

.SS "int ltc_decoder_queue_length (\fBLTCDecoder\fP * d)"
count number of LTC frames currently in the queue 
.PP
\fBParameters:\fP
.RS 4
\fId\fP decoder handle 
.RE
.PP
\fBReturns:\fP
.RS 4
number of queued frames 
.RE
.PP

.SS "int ltc_decoder_read (\fBLTCDecoder\fP * d, \fBLTCFrameExt\fP * frame)"
Decoded LTC frames are placed in a queue\&. This function retrieves a frame from the queue, and stores it at LTCFrameExt*
.PP
\fBParameters:\fP
.RS 4
\fId\fP decoder handle 
.br
\fIframe\fP the decoded LTC frame is copied there 
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success or 0 when no frames queued\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcdecode\&.c\fP\&.
.SS "void ltc_decoder_write (\fBLTCDecoder\fP * d, \fBltcsnd_sample_t\fP * buf, size_t size, \fBltc_off_t\fP posinfo)"
Feed the LTC decoder with new audio samples\&.
.PP
Parse raw audio for LTC timestamps\&. Once a complete LTC frame has been decoded it is pushed into a queue (\fBltc_decoder_read\fP)
.PP
\fBParameters:\fP
.RS 4
\fId\fP decoder handle 
.br
\fIbuf\fP pointer to ltcsnd_sample_t - unsigned 8 bit mono audio data 
.br
\fIsize\fP number of samples to parse 
.br
\fIposinfo\fP (optional, recommended) sample-offset in the audio-stream\&. It is added to \fBoff_start\fP, \fBoff_end\fP in \fBLTCFrameExt\fP and should be monotonic (ie incremented by \fBsize\fP for every call to ltc_decoder_write) 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcdecode\&.c\fP\&.
.SS "void ltc_decoder_write_float (\fBLTCDecoder\fP * d, float * buf, size_t size, \fBltc_off_t\fP posinfo)"
wrapper to \fBltc_decoder_write\fP that accepts floating point audio samples\&. Note: internally libltc uses 8 bit only\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP decoder handle 
.br
\fIbuf\fP pointer to audio sample data 
.br
\fIsize\fP number of samples to parse 
.br
\fIposinfo\fP (optional, recommended) sample-offset in the audio-stream\&. 
.RE
.PP

.SS "void ltc_decoder_write_s16 (\fBLTCDecoder\fP * d, short * buf, size_t size, \fBltc_off_t\fP posinfo)"
wrapper to \fBltc_decoder_write\fP that accepts signed 16 bit audio samples\&. Note: internally libltc uses 8 bit only\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP decoder handle 
.br
\fIbuf\fP pointer to audio sample data 
.br
\fIsize\fP number of samples to parse 
.br
\fIposinfo\fP (optional, recommended) sample-offset in the audio-stream\&. 
.RE
.PP

.SS "void ltc_decoder_write_u16 (\fBLTCDecoder\fP * d, short * buf, size_t size, \fBltc_off_t\fP posinfo)"
wrapper to \fBltc_decoder_write\fP that accepts unsigned 16 bit audio samples\&. Note: internally libltc uses 8 bit only\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP decoder handle 
.br
\fIbuf\fP pointer to audio sample data 
.br
\fIsize\fP number of samples to parse 
.br
\fIposinfo\fP (optional, recommended) sample-offset in the audio-stream\&. 
.RE
.PP

.SS "void ltc_encoder_buffer_flush (\fBLTCEncoder\fP * e)"
reset the write-pointer of the encoder-buffer 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.RE
.PP

.SS "\fBLTCEncoder\fP* ltc_encoder_create (double sample_rate, double fps, int use_date)"
Allocate and initialize LTC audio encoder\&.
.PP
Note: if fps equals to 29\&.97 or 30000\&.0/1001\&.0, the \fBLTCFrame\fP's 'dfbit' bit is set to 1 to indicate drop-frame timecode\&.
.PP
\fBParameters:\fP
.RS 4
\fIsample_rate\fP audio sample rate (eg\&. 48000) 
.br
\fIfps\fP video-frames per second (e\&.g\&. 25\&.0) 
.br
\fIuse_date\fP use LTC-user-data for date 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP, and \fBltcencode\&.c\fP\&.
.SS "int ltc_encoder_dec_timecode (\fBLTCEncoder\fP * e)"
move the encoder to the previous timecode frame\&. uses \fBltc_frame_decrement()\fP internally\&. 
.SS "int ltc_encoder_encode_byte (\fBLTCEncoder\fP * e, int byte, double speed)"
Generate LTC audio for given byte of the LTC-frame and place it into the internal buffer\&.
.PP
see \fBltc_encoder_get_buffer\fP and \fBltc_encoder_get_bufptr\fP
.PP
LTC has 10 bytes per frame: 0 <= bytecnt < 10 use SMPTESetTime(\&.\&.) to set the current frame before Encoding\&. see tests/encoder\&.c for an example\&.
.PP
The default output signal is @ -3dBFS (38\&.\&.218 at 8 bit unsigned)\&. see also \fBltc_encoder_set_volume\fP
.PP
if speed is <0 bits are encoded in reverse\&. slowdown > 10\&.0 requires custom buffer sizes; see \fBltc_encoder_set_bufsize\fP
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIbyte\fP byte of the LTC-frame to encode 0\&.\&.9 
.br
\fIspeed\fP vari-speed, <1\&.0 faster, >1\&.0 slower ; must be != 0
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 if byte is invalud or buffer overflow (speed > 10\&.0) 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP\&.
.SS "void ltc_encoder_encode_frame (\fBLTCEncoder\fP * e)"
encode a full LTC frame at fixed speed\&. This is equivalent to calling \fBltc_encoder_encode_byte\fP 10 times for bytes 0\&.\&.9 with speed 1\&.0\&.
.PP
Note: The buffer must be empty before calling this function\&. This is usually the case if it is read with \fBltc_encoder_get_buffer\fP after calling this function\&.
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP, and \fBltcencode\&.c\fP\&.
.SS "void ltc_encoder_free (\fBLTCEncoder\fP * e)"
release encoder data structure 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP, and \fBltcencode\&.c\fP\&.
.SS "int ltc_encoder_get_buffer (\fBLTCEncoder\fP * e, \fBltcsnd_sample_t\fP * buf)"
copy the accumulated encoded audio to the given sample-buffer and flush the buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIbuf\fP place to store the audio-samples, needs to be large enough to hold \fBltc_encoder_get_buffersize\fP bytes 
.RE
.PP
\fBReturns:\fP
.RS 4
the number of bytes written to the memory area pointed to by buf\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP\&.
.SS "size_t ltc_encoder_get_buffersize (\fBLTCEncoder\fP * e)"
query the length of the internal buffer\&. It is allocated to hold audio-frames for exactly one LTC frame for the given sample-rate and frame-rate\&. ie\&. (1 + sample-rate / fps) bytes
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.RE
.PP
\fBReturns:\fP
.RS 4
size of the allocated internal buffer\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP\&.
.SS "\fBltcsnd_sample_t\fP* ltc_encoder_get_bufptr (\fBLTCEncoder\fP * e, int * size, int flush)"
get a pointer to the accumulated encoded audio-data\&.
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIsize\fP if set, the number of valid bytes in the buffer is stored there 
.br
\fIflush\fP call \fBltc_encoder_buffer_flush\fP - reset the buffer write-pointer 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to encoder-buffer 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP, and \fBltcencode\&.c\fP\&.
.SS "void ltc_encoder_get_frame (\fBLTCEncoder\fP * e, \fBLTCFrame\fP * f)"
low-level access to the internal \fBLTCFrame\fP data
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIf\fP return LTC frame data 
.RE
.PP

.SS "void ltc_encoder_get_timecode (\fBLTCEncoder\fP * e, \fBSMPTETimecode\fP * t)"
query current encoder timecode\&.
.PP
Note: the decoder store its internal state in an LTC-frame, this function converts that LTC-Frame into \fBSMPTETimecode\fP on demand
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIt\fP is set to current timecode 
.RE
.PP

.SS "int ltc_encoder_inc_timecode (\fBLTCEncoder\fP * e)"
move the encoder to the next timecode frame\&. uses \fBltc_frame_increment()\fP internally\&. 
.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP, and \fBltcencode\&.c\fP\&.
.SS "int ltc_encoder_reinit (\fBLTCEncoder\fP * e, double sample_rate, double fps, int use_date)"
change the encoder settings without re-allocating any library internal data structure (realtime safe)\&.
.PP
This call will fail if the internal buffer is too small to hold one full LTC frame\&. Use \fBltc_encoder_set_bufsize\fP to prepare an internal buffer large enough to accommodate all sample_rate, fps combinations that you would like to re-init to\&.
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIsample_rate\fP audio sample rate (eg\&. 48000) 
.br
\fIfps\fP video-frames per second (e\&.g\&. 25\&.0) 
.br
\fIuse_date\fP use LTC-user-data for date 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcencode\&.c\fP\&.
.SS "int ltc_encoder_set_bufsize (\fBLTCEncoder\fP * e, double sample_rate, double fps)"
set a custom size for the internal buffer\&.
.PP
This is needed if you are planning to call \fBltc_encoder_reinit()\fP or if you want to keep more than one LTC frame's worth of data in the library's internal buffer\&.
.PP
The buffer-size is (1 + sample_rate / fps) bytes\&. resizing the internal buffer will flush all existing data in it - alike \fBltc_encoder_buffer_flush\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIsample_rate\fP audio sample rate (eg\&. 48000) 
.br
\fIfps\fP video-frames per second (e\&.g\&. 25\&.0) 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 if allocation fails (which makes the encoder unusable, call \fBltc_encoder_free\fP or realloc the buffer) 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcencode\&.c\fP\&.
.SS "void ltc_encoder_set_filter (\fBLTCEncoder\fP * e, double rise_time)"
set encoder signal rise-time / signal filtering
.PP
LTC signal should have a rise time of 25 us +/- 5 us\&. by default the encoder honors this and low-pass filters the output depending on the sample-rate\&.
.PP
If you want a perfect square wave, set 'rise_time' to 0\&.
.PP
Note \fBltc_encoder_reinit\fP resets the filter-time-constant to use the default 25us for the given sample-rate, overriding any value previously set with \fBltc_encoder_set_filter\fP
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIrise_time\fP the signal rise-time in us (10^-6 sec), set to 0 for perfect square wave, default 25\&.0 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcencode\&.c\fP\&.
.SS "void ltc_encoder_set_frame (\fBLTCEncoder\fP * e, \fBLTCFrame\fP * f)"
low-level access to the internal \fBLTCFrame\fP data\&.
.PP
Note: be careful to about f->dfbit, the encoder sets this [only] upon initialization\&.
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIf\fP LTC frame data to use 
.RE
.PP

.SS "void ltc_encoder_set_timecode (\fBLTCEncoder\fP * e, \fBSMPTETimecode\fP * t)"
set the encoder LTC-frame from given \fBSMPTETimecode\fP\&. The next call to \fBltc_encoder_encode_byte\fP or \fBltc_encoder_encode_frame\fP will encode this time to LTC audio-samples\&.
.PP
Internally this call uses \fBltc_time_to_frame\fP because the LTCEncoder operates on LTCframes only\&.
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIt\fP timecode to set\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBexample_encode\&.c\fP, and \fBltcencode\&.c\fP\&.
.SS "int ltc_encoder_set_volume (\fBLTCEncoder\fP * e, double dBFS)"
set the volume of the generated LTC signal
.PP
typically LTC is sent at 0dBu ; in EBU callibrated systems that corresponds to -18dBFS\&. - by default libltc creates -3dBFS
.PP
since libltc generated 8bit audio-data, the minium dBFS is about -42dB which corresponds to 1 bit\&.
.PP
0dB corresponds to a signal range of 127 1\&.\&.255 with 128 at the center\&.
.PP
\fBParameters:\fP
.RS 4
\fIe\fP encoder handle 
.br
\fIdBFS\fP the volume in dB full-scale (<= 0\&.0) 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 if the value was out of range 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcencode\&.c\fP\&.
.SS "int ltc_frame_decrement (\fBLTCFrame\fP * frame, int fps, int use_date)"
decrement the timecode by one Frame (1/framerate seconds) and set the Frame's parity bit accordingly (see \fBltc_frame_set_parity\fP)
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP the LTC-timecode to decrement 
.br
\fIfps\fP integer framerate (for drop-frame-timecode set frame->dfbit and round-up the fps)\&. 
.br
\fIuse_date\fP - interpret user-data as date and decrement date if timecode wraps at 24h\&. (Note: leap-years are taken into account, but since the year is two-digit only, the 100,400yr rules are ignored\&. '00' is assumed to be year 2000 which was a leap year\&.) 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if timecode was wrapped around at 23:59:59:ff, 0 otherwise 
.RE
.PP

.SS "int ltc_frame_increment (\fBLTCFrame\fP * frame, int fps, int use_date)"
increment the timecode by one Frame (1/framerate seconds) and set the Frame's parity bit accordingly (see \fBltc_frame_set_parity\fP)
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP the LTC-timecode to increment 
.br
\fIfps\fP integer framerate (for drop-frame-timecode set frame->dfbit and round-up the fps)\&. 
.br
\fIuse_date\fP - interpret user-data as date and increment date if timecode wraps after 24h\&. (Note: leap-years are taken into account, but since the year is two-digit only, the 100,400yr rules are ignored\&. '00' is assumed to be year 2000 which was a leap year\&.) 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if timecode was wrapped around after 23:59:59:ff, 0 otherwise 
.RE
.PP

.SS "void ltc_frame_reset (\fBLTCFrame\fP * frame)"
reset all values of a LTC FRAME to zero, except for the sync-word (0x3FFD) at the end\&. The sync word is set according to architecture (big/little endian)\&. also set the Frame's parity bit accordingly (see \fBltc_frame_set_parity\fP) 
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP the \fBLTCFrame\fP to reset 
.RE
.PP

.SS "void ltc_frame_set_parity (\fBLTCFrame\fP * frame)"
Set the parity of the LTC frame\&.
.PP
Bi-Phase Mark Phase Correction bit (bit 27) may be set or cleared so that that every 80-bit word contains an even number of zeroes\&. This means that the phase in every Sync Word will be the same\&.
.PP
This is merely cosmetic; the motivation to keep the polarity of the waveform constant is to make finding the Sync Word visibly (on a scope) easier\&.
.PP
There is usually no need to call this function directly\&. The encoder utility functions \fBltc_time_to_frame\fP, \fBltc_frame_increment\fP and \fBltc_frame_decrement\fP include a call to it\&.
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP the LTC to analyze and set or clear the biphase_mark_phase_correction bit\&. 
.RE
.PP

.SS "void ltc_frame_to_time (\fBSMPTETimecode\fP * stime, \fBLTCFrame\fP * frame, int set_date)"
convert binary \fBLTCFrame\fP into \fBSMPTETimecode\fP struct 
.PP
\fBParameters:\fP
.RS 4
\fIstime\fP output 
.br
\fIframe\fP input 
.br
\fIset_date\fP if non-zero, the user-fields in \fBLTCFrame\fP will be parsed into the date variable of \fBSMPTETimecode\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBltcdecode\&.c\fP\&.
.SS "void ltc_time_to_frame (\fBLTCFrame\fP * frame, \fBSMPTETimecode\fP * stime, int set_date)"
convert \fBSMPTETimecode\fP struct into its binary LTC representation\&. and set the Frame's parity bit accordingly (see \fBltc_frame_set_parity\fP)
.PP
\fBParameters:\fP
.RS 4
\fIframe\fP output - the frame to be set 
.br
\fIstime\fP input - timecode input 
.br
\fIset_date\fP if non-zero, the user-fields in \fBLTCFrame\fP will be set from the date in \fBSMPTETimecode\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libltc from the source code\&.
